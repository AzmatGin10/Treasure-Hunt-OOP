        queue = [(self.startX, self.startY)]
        distanceLevels = {(self.startX, self.startY): 0}
        currentLevel = 0

        while queue:
            nextLevel = []
            for i in range(len(queue)):
                currentX, currentY = queue[i]
                if currentLevel > minDistance:
                    possibleExits.append((currentX, currentY))
                
                random.shuffle(directions)
                
                for dir in directions:
                    newX, newY = currentX + dir[0], currentY + dir[1]
                    
                    if 0 < newX < self.mazeSize and 0 < newY < self.mazeSize and not self.maze[newY][newX]:
                        if (newX, newY) not in distanceLevels:
                            distanceLevels[(newX, newY)] = currentLevel + 1
                            nextLevel.append((newX, newY))
            
            queue = nextLevel
            currentLevel += 1

        possibleExits = [exit for exit in possibleExits if sum(
            1 for dir in directions if 0 <= exit[1] + dir[1] < self.mazeSize and 0 <= exit[0] + dir[0] < self.mazeSize and 
            self.maze[exit[1] + dir[1]][exit[0] + dir[0]]
        ) >= 3]